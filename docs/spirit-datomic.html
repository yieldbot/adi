<html>
  <head>
    <meta content=\"chrome=1\" http-equiv=\"X-UA-Compatible\" />
    <meta charset=\"utf-8\" /><meta content=\"width=device-width, initial-scale=1, user-scalable=no\" name=\"viewport\" />
    <link rel="icon" href="favicon.ico?v=2" type="image/png" />
    <title>datomic - spirit.datomic API Reference</title>
    <script src="js/highlight.min.js"></script>
    <script src="js/gumshoe.min.js"></script>
    <script src="js/smooth-scroll.min.js"></script>

    <link rel="stylesheet" href="css/page.css">
    <link rel="stylesheet" href="css/api.css">
    <link rel="stylesheet" href="css/code.css">
    <link rel="stylesheet" href="css/highlight.css">
  </head>
    
  <body>
    <header class="top">
      <ul><li><a href="index.html">home</a></li><li><a href="spirit-datomic.html">datomic</a></li></ul>
    </header>
    <header>      
      <div class="heading">
        <h1>datomic</h1>
        <h3>spirit.datomic API Reference</h3>
        <hr/>
        <div class=\"info\">
          <h5>Author: Chris Zheng<b>&nbsp;&nbsp;<a href="mailto:z@caudate.me">(z@caudate.me)</a></b></h5>
          <h5>Date: 31 May 2017</h5>
          <h5>Repository: <a href="https://www.github.com/zcaudate/spirit">https://www.github.com/zcaudate/spirit</a></h5>
          <h5>Version: 0.5.1</h5>
        </div>
        <br/>
        <hr/>
      </div>

      <h4><a href="#introduction">1 &nbsp; Introduction</a></h4><h5>&nbsp;&nbsp;<i><a href="#installation">1.1 &nbsp; Installation</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#outline">1.2 &nbsp; Outline</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#architecture">1.3 &nbsp; Architecture</a></i></h5><h4><a href="#api">2 &nbsp; API</a></h4><h5>&nbsp;&nbsp;<i><a href="#connect">2.1 &nbsp; connect!</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#insert">2.2 &nbsp; insert!</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#select">2.3 &nbsp; select</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#query">2.4 &nbsp; query</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#update">2.5 &nbsp; update!</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#retract">2.6 &nbsp; retract!</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#update-in">2.7 &nbsp; update-in!</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#retract-in">2.8 &nbsp; retract-in!</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#transact">2.9 &nbsp; transact!</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#delete">2.10 &nbsp; delete!</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#delete-in">2.11 &nbsp; delete-in!</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#delete-all">2.12 &nbsp; delete-all!</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#parameters">2.13 &nbsp; Parameters</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#options">2.14 &nbsp; Options</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#pipeline">2.15 &nbsp; Pipeline</a></i></h5><h4><a href="#schema">3 &nbsp; Schema</a></h4><h5>&nbsp;&nbsp;<i><a href="#basics">3.1 &nbsp; Basics</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#shorthand">3.1.1 &nbsp; Shorthand</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#attributes">3.2 &nbsp; Attributes</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#type">3.3 &nbsp; :type</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#ref">3.4 &nbsp; :ref</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#enum">3.5 &nbsp; :enum</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#cardinality">3.6 &nbsp; :cardinality</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#unique">3.7 &nbsp; :unique</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#doc">3.8 &nbsp; :doc</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#index">3.9 &nbsp; :index</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#fulltext">3.10 &nbsp; :fulltext</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#is-component">3.11 &nbsp; :isComponent</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#no-history">3.12 &nbsp; :noHistory</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#required">3.13 &nbsp; :required</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#restrict">3.14 &nbsp; :restrict</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#default">3.15 &nbsp; :default</a></i></h5><h4><a href="#connection-params">4 &nbsp; Connection Params</a></h4><h5>&nbsp;&nbsp;<i><a href="#connection">4.1 &nbsp; :connection</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#creating-a-datastore">4.1.1 &nbsp; creating a datastore</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#more-datastores">4.1.2 &nbsp; more datastores</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#key--value-input">4.1.3 &nbsp; key/value input</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#map-input">4.1.4 &nbsp; map input</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#different-sinks">4.1.5 &nbsp; different sinks</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#update-example">4.1.6 &nbsp; update example</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#delete-example">4.1.7 &nbsp; delete example</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#db">4.2 &nbsp; :db</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#key--value-input-0">4.2.1 &nbsp; key/value input</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#map-input-0">4.2.2 &nbsp; map input</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#overwriting">4.2.3 &nbsp; overwriting</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#at">4.3 &nbsp; :at</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#time-travel">4.3.1 &nbsp; time travel</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#syntactic-sugar">4.3.2 &nbsp; syntactic sugar</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#transaction-id">4.3.3 &nbsp; transaction id</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#transaction-time">4.3.4 &nbsp; transaction time</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#mix-and-match">4.3.5 &nbsp; mix and match</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#return">4.4 &nbsp; :return</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#ids">4.4.1 &nbsp; :ids</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#entities">4.4.2 &nbsp; :entities</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#data">4.4.3 &nbsp; :data</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#transact-0">4.5 &nbsp; :transact</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#resolve">4.5.1 &nbsp; :resolve</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#datomic">4.5.2 &nbsp; :datomic</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#promise">4.5.3 &nbsp; :promise</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#async">4.5.4 &nbsp; :async</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#simulate">4.6 &nbsp; :simulate</a></i></h5><h4><a href="#schema-params">5 &nbsp; Schema Params</a></h4><h5>&nbsp;&nbsp;<i><a href="#schema-0">5.1 &nbsp; :schema</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#book">5.1.1 &nbsp; book</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#partial-schema">5.1.2 &nbsp; partial schema</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#more-examples">5.1.3 &nbsp; more examples</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#pull">5.2 &nbsp; :pull</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#defaults">5.2.1 &nbsp; defaults</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#checked-and-unchecked">5.2.2 &nbsp; :checked and :unchecked</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#id">5.2.3 &nbsp; :id</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#forward-walk">5.2.4 &nbsp; forward walk</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#reverse-walk">5.2.5 &nbsp; reverse walk</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#yield">5.2.6 &nbsp; :yield</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#recursion">5.2.7 &nbsp; recursion</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#access">5.3 &nbsp; :access</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#restrictions">5.3.1 &nbsp; restrictions</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#combination">5.3.2 &nbsp; combination</a></i></h5><h4><a href="#options-0">6 &nbsp; Options</a></h4><h5>&nbsp;&nbsp;<i><a href="#first">6.1 &nbsp; :first</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#ids-0">6.2 &nbsp; :ids</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#blank">6.3 &nbsp; :blank</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#default-setting">6.3.1 &nbsp; default setting</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#pull-behaviour">6.3.2 &nbsp; pull behaviour</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#access-behaviour">6.3.3 &nbsp; access behaviour</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#ref-traversal">6.3.4 &nbsp; ref traversal</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#ban-expressions">6.4 &nbsp; :ban-expressions</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#ban-top-id">6.5 &nbsp; :ban-top-id</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#ban-body-ids">6.6 &nbsp; :ban-body-ids</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#ban-ids">6.7 &nbsp; :ban-ids</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#raw">6.8 &nbsp; :raw</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#spirit">6.9 &nbsp; :spirit</a></i></h5><h4><a href="#pipeline-0">7 &nbsp; Pipeline</a></h4><h5>&nbsp;&nbsp;<i><a href="#pre-process">7.1 &nbsp; :pre-process</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#pre-require">7.2 &nbsp; :pre-require</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#pre-mask">7.3 &nbsp; :pre-mask</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#pre-transform">7.4 &nbsp; :pre-transform</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#fill-empty">7.5 &nbsp; :fill-empty</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#fill-assoc">7.6 &nbsp; :fill-assoc</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#ignore">7.7 &nbsp; :ignore</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#allow">7.8 &nbsp; :allow</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#validate">7.9 &nbsp; :validate</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#convert">7.10 &nbsp; :convert</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#post-require">7.11 &nbsp; :post-require</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#post-mask">7.12 &nbsp; :post-mask</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#post-transform">7.13 &nbsp; :post-transform</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#post-process">7.14 &nbsp; :post-process</a></i></h5>
      <!--nav data-gumshoe-header>
        <ul data-gumshoe>
          <a data-scroll class="top" href="#page-top">TOP</a>
        </ul>
      </nav-->
      <br/>
      <br/>
    </header>
    
    <div class="content">
      <section>
        <div class="heading">
          <h1>datomic</h1>
          <h3>spirit.datomic API Reference</h3>
          <hr/>
          <div class=\"info\">
            <h5>Author: Chris Zheng<b>&nbsp;&nbsp;<a href="mailto:z@caudate.me">(z@caudate.me)</a></b></h5>
            <h5>Date: 31 May 2017</h5>
            <h5>Repository: <a href="https://www.github.com/zcaudate/spirit">https://www.github.com/zcaudate/spirit</a></h5>
            <h5>Version: 0.5.1</h5>
          </div>
          <br/>
          <hr/>
        </div>
        <div><span id="introduction"></span><h2><b>1 &nbsp;&nbsp; Introduction</b></h2></div><div><p><a href='https://www.github.com/zcaudate/spirit'>spirit</a> provides a simple, intuitive data layer to access datomic using a document-based syntax, as well as a data-processing pipeline for fine-grain manipulation and access of data.</p></div><div><span id="installation"></span><h3>1.1 &nbsp;&nbsp; Installation</h3></div><div><p>Add to <code>project.clj</code> dependencies:</p><pre><code>&#91;im.chit/spirit.datomic &quot;0.5.1&quot;&#93;</code></pre><p>All functionality is contained in the <code>spirit.datomic</code> namespace:</p></div><div class="code"><pre><code class="clojure">(require '[spirit.datomic :as datomic])</code></pre></div><div><span id="outline"></span><h3>1.2 &nbsp;&nbsp; Outline</h3></div><div><p><a href='https://www.github.com/zcaudate/spirit'>spirit.datomic</a> provides the following advantages</p><ul><li>Using the schema as a 'type' system to process incoming data.</li><li>Relations mapped to nested object structures (using a graph-like notion)</li><li>Nested maps/objects as declarative logic queries.</li><li>Custom views on data (similar to the <code>:pull</code> api)</li></ul></div><div><span id="architecture"></span><h3>1.3 &nbsp;&nbsp; Architecture</h3></div><div><p>The architecture can be seen below:</p></div><div class="figure"><a id="img-img--spirit-png"></a><div class="img"><img line="{:row 36, :col 1, :end-row 36, :end-col 49}" src="img/spirit.png" width="100%" /></div><p></p></div><div><span id="api"></span><h2><b>2 &nbsp;&nbsp; API</b></h2></div><div><p>Top Level API's are listed below, first, we define a schema:</p></div><div class="code"><pre><code class="clojure">(def schema-api
 {:account {:user     [{:required true
                        :unique :value}]
            :books    [{:type :ref
                        :cardinality :many
                        :ref  {:ns :book}}]}
  :book   {:name    [{:required true
                      :fulltext true}]
           :author  [{:fulltext true}]}})</code></pre></div><div><span id="connect"></span><h3>2.1 &nbsp;&nbsp; connect!</h3></div><div><p><code>connect!</code> creates a connection to a datomic datastore:</p></div><div class="code"><pre><code class="clojure">(def api-ds (datomic/connect! &quot;datomic:mem://datomic-api&quot; schema-api true true))</code></pre></div><div><span id="insert"></span><h3>2.2 &nbsp;&nbsp; insert!</h3></div><div><p><code>insert!</code> puts data into the datastore:</p></div><div class="code"><pre><code class="clojure">(datomic/insert! api-ds
                 [{:account {:user &quot;Anne&quot;
                             :books #{{:name &quot;Watership Down&quot;}}}}
                  {:account {:user &quot;Bob&quot;
                             :books #{{:name &quot;Canterbury Tales&quot;}}}}])</code></pre></div><div><span id="select"></span><h3>2.3 &nbsp;&nbsp; select</h3></div><div><p><code>select</code> retrieves from the datastore by category:</p></div><div class="code"><pre><code class="clojure">(datomic/select api-ds :book)
=&gt; #{{:book {:name &quot;Watership Down&quot;}}
     {:book {:name &quot;Canterbury Tales&quot;}}}</code></pre></div><div><p>or by the spirit query syntax:</p></div><div class="code"><pre><code class="clojure">(datomic/select api-ds {:book/name '_})
=&gt; #{{:book {:name &quot;Watership Down&quot;}}
     {:book {:name &quot;Canterbury Tales&quot;}}}</code></pre></div><div><span id="query"></span><h3>2.4 &nbsp;&nbsp; query</h3></div><div><p><code>query</code> retrieves results using a datomic style query</p></div><div class="code"><pre><code class="clojure">(datomic/query api-ds '[:find ?self :where
                  [?self :book/name _]]
           [])
=&gt; #{{:book {:name &quot;Watership Down&quot;}}
     {:book {:name &quot;Canterbury Tales&quot;}}}</code></pre></div><div><span id="update"></span><h3>2.5 &nbsp;&nbsp; update!</h3></div><div><p><code>update!</code> will take a query and update all datoms that match with additional values:</p></div><div class="code"><pre><code class="clojure">(datomic/update! api-ds
             {:book/name &quot;Watership Down&quot;}
             {:book/author &quot;Richard Adams&quot;})

(datomic/select api-ds {:book/name &quot;Watership Down&quot;})
=&gt; #{{:book {:name &quot;Watership Down&quot;, :author &quot;Richard Adams&quot;}}}</code></pre></div><div><span id="retract"></span><h3>2.6 &nbsp;&nbsp; retract!</h3></div><div><p><code>retract!</code> will take a query and retract keys in all datoms that match</p></div><div class="code"><pre><code class="clojure">(datomic/retract! api-ds
              {:book/name &quot;Watership Down&quot;}
              [:book/author])

(datomic/select api-ds {:book/name &quot;Watership Down&quot;})
=&gt; #{{:book {:name &quot;Watership Down&quot;}}}</code></pre></div><div><span id="update-in"></span><h3>2.7 &nbsp;&nbsp; update-in!</h3></div><div><p><code>update-in!</code> will take a query and update all datoms through the access path</p></div><div class="code"><pre><code class="clojure">(datomic/update-in! api-ds
                {:account/user &quot;Anne&quot;}
                [:account/books {:name &quot;Watership Down&quot;}]
                {:author &quot;Richard Adams&quot;})

(datomic/select api-ds {:book/name &quot;Watership Down&quot;})
=&gt; #{{:book {:name &quot;Watership Down&quot;, :author &quot;Richard Adams&quot;}}}</code></pre></div><div><span id="retract-in"></span><h3>2.8 &nbsp;&nbsp; retract-in!</h3></div><div><p><code>retract-in!</code> will take a query and retracts all keys through the access path</p></div><div class="code"><pre><code class="clojure">(datomic/retract-in! api-ds
                {:account/user &quot;Anne&quot;}
                [:account/books {:name &quot;Watership Down&quot;}]
                [:author])

(datomic/select api-ds {:book/name &quot;Watership Down&quot;})
=&gt; #{{:book {:name &quot;Watership Down&quot;}}}</code></pre></div><div><span id="transact"></span><h3>2.9 &nbsp;&nbsp; transact!</h3></div><div><p><code>transact!</code> takes datomic datoms for update:</p></div><div class="code"><pre><code class="clojure">(datomic/transact! api-ds
               [{:db/id (datomic/iid :charlie)
                 :account/user &quot;Charlie&quot;}])
;;=&gt; [{:db {:id 17592186045423}
;;     :account {:user &quot;Charlie&quot;} }]

(datomic/select api-ds :account)
=&gt; #{{:account {:user &quot;Anne&quot;}} {:account {:user &quot;Bob&quot;}} {:account {:user &quot;Charlie&quot;}}}</code></pre></div><div><span id="delete"></span><h3>2.10 &nbsp;&nbsp; delete!</h3></div><div><p><code>delete!</code> removes entities from the datastore:</p></div><div class="code"><pre><code class="clojure">(datomic/delete! api-ds {:account/user &quot;Charlie&quot;})
;;=&gt; #{{:db {:id 17592186045427}
;;      :account {:user &quot;Charlie&quot;}}}

(datomic/select api-ds :account)
=&gt; #{{:account {:user &quot;Anne&quot;}} {:account {:user &quot;Bob&quot;}}}</code></pre></div><div><span id="delete-in"></span><h3>2.11 &nbsp;&nbsp; delete-in!</h3></div><div><p><code>delete-in!</code> will take a query and deletes all entities from the access path:</p></div><div class="code"><pre><code class="clojure">(datomic/delete-in! api-ds {:account/user &quot;Bob&quot;}
                    [:account/books {:name '_}])
;;=&gt; #{{:db {:id 17592186045421}
;;      :book {:name &quot;Canterbury Tales&quot;}}}

  
(datomic/select api-ds :book)
=&gt; #{{:book {:name &quot;Watership Down&quot;}}}</code></pre></div><div class="code"><pre><code class="clojure">(datomic/select api-ds :book :debug)

;;(datomic/insert! api-ds {:account {:user &quot;Chris&quot;}} :debug)</code></pre></div><div><span id="delete-all"></span><h3>2.12 &nbsp;&nbsp; delete-all!</h3></div><div><p><code>delete-all!</code> will takes a query and deletes all entities govered by the access model:</p></div><div class="code"><pre><code class="clojure">(datomic/delete-all! api-ds {:account/user &quot;Anne&quot;}
                     :access {:account {:books :checked}})
;;=&gt; #{{:db {:id 17592186045418}}}
;;      :account  {:user &quot;Anne&quot;,
;;                 :books #{{:name &quot;Watership Down&quot;,
;;                           :+ {:db {:id 17592186045419}}}}}, 
  
(datomic/select api-ds :book)
=&gt; #{}</code></pre></div><div><span id="parameters"></span><h3>2.13 &nbsp;&nbsp; Parameters</h3></div><div><p>Apart from the core query and transactional functions, there are many parameters and customisations that can be tweaked. This is very terse, but it is important for fine grain control of data. <code>spirit</code> comes with a bunch of bells and whistles for data - some inherited from the underlying datomic api, others built to deal with the pipeline for schema-assisted transformation of data. There are keywords reserved by the top-level operations that can be set/overwritten through arguments.</p><p>Connection related entries:</p><ul><li><code>:connection</code></li><li><code>:db</code></li><li><code>:at</code></li><li><code>:return</code></li><li><code>:transact</code></li></ul><p>Schema related entries:</p><ul><li><code>:schema</code></li><li><code>:pull</code></li><li><code>:access</code></li></ul></div><div><span id="options"></span><h3>2.14 &nbsp;&nbsp; Options</h3></div><div><p>There is a seperate param entry holding all the miscellaneous options, called (as you may have guessed) <code>options</code> and each sub-entry will be covered seperately:</p><ul><li><code>:first</code></li><li><code>:ids</code></li><li><code>:ban-expressions</code></li><li><code>:ban-ids</code></li><li><code>:ban-top-id</code></li><li><code>:ban-body-ids</code></li><li><code>:raw</code></li><li><code>:spirit</code></li></ul></div><div><span id="pipeline"></span><h3>2.15 &nbsp;&nbsp; Pipeline</h3></div><div><p>The <code>:pipeline</code> entry has it's own set of sub-keys. They will be described in its own chapter:</p><ul><li><code>:pre-process</code></li><li><code>:pre-require</code></li><li><code>:pre-mask</code></li><li><code>:pre-transform</code></li><li><code>:fill-empty</code></li><li><code>:fill-assoc</code></li><li><code>:ignore</code></li><li><code>:allow</code></li><li><code>:validate</code></li><li><code>:convert</code></li><li><code>:post-require</code></li><li><code>:post-mask</code></li><li><code>:post-transform</code></li><li><code>:post-process</code></li></ul></div><div><span id="schema"></span><h2><b>3 &nbsp;&nbsp; Schema</b></h2></div><div><span id="basics"></span><h3>3.1 &nbsp;&nbsp; Basics</h3></div><div><p>The schema can be defined as follows:</p></div><div class="code"><pre><code class="clojure">(def schema
  {:&lt;ns&gt; {:&lt;name0&gt; [{&lt;attr0&gt; &lt;value&gt;
                    &lt;attr1&gt; &lt;value&gt;}]
          :&lt;name1&gt; {:&lt;sub&gt; [{&lt;attr0&gt; &lt;value&gt;
                            &lt;attr1&gt; &lt;value&gt;}]}}
   :&lt;ns&gt;/&lt;name&gt;.&lt;sub&gt; [{&lt;attr0&gt; &lt;value&gt;
                        &lt;attr1&gt; &lt;value&gt;}]})</code></pre></div><div><p>Where the concatenated <code>&lt;ns&gt;</code>, <code>&lt;name&gt;</code> and <code>&lt;sub&gt;</code> maps to datomic's <code>:db/ident</code> and a map inside a vector represents definition of database attributes.</p></div><div><span id="shorthand"></span><h3><i>3.1.1 &nbsp;&nbsp; Shorthand</i></h3></div><div><p><code>spirit</code> offers sane defaults and attempts to remove noise as much as possible. Therefore, the datomic schema:</p></div><div class="code"><pre><code class="clojure">{:db/id #db/id[:db.part/db]
 :db/ident :person/name
 :db/valueType :db.type/string
 :db/cardinality :db.cardinality/one
 :db/doc &quot;A person's name&quot;
 :db.install/_attribute :db.part/db}</code></pre></div><div><p>Can be represented in spirit as:</p></div><div class="code"><pre><code class="clojure">{:person {:name [{:doc &quot;a person's name&quot;}]}}</code></pre></div><div><p>And if the defaults were made explicit:</p></div><div class="code"><pre><code class="clojure">{:person {:name [{:type :string
                  :cardinality :one
                  :doc &quot;a person's name&quot;}]}}</code></pre></div><div><span id="attributes"></span><h3>3.2 &nbsp;&nbsp; Attributes</h3></div><div><p>Core:</p><ul><li><code>:type</code></li><li><code>:ref</code></li><li><code>:enum</code></li><li><code>:cardinality</code></li></ul><p>Optionals:</p><ul><li><code>:unique</code></li><li><code>:doc</code></li><li><code>:index</code></li><li><code>:fulltext</code></li><li><code>:isComponent</code></li><li><code>:noHistory</code></li></ul><p>Additional</p><ul><li><code>:required</code></li><li><code>:restrict</code></li><li><code>:default</code></li></ul></div><div><span id="type"></span><h3>3.3 &nbsp;&nbsp; :type</h3></div><div><p>Specifies the type of value that can be associated with an attribute. The type is expressed as a keyword. The values allowed are:</p><ul><li><code>:bigdec</code> arbitrary precision floating point numbers, maps to <code>java.math.BigDecimal</code></li><li><code>:bigint</code> arbitrary precision integers, maps to <code>java.math.BigInteger</code>.</li><li><code>:boolean</code> boolean data.</li><li><code>:bytes</code>  small binary data. Maps to byte array.</li><li><code>:double</code> double-precision 64-bit IEEE 754 floating point.</li><li><code>:enum</code> typed keywords.</li><li><code>:float</code> single-precision 32-bit IEEE 754 floating point.</li><li><code>:instant</code> instants in time, maps to <code>java.util.Date</code>.</li><li><code>:keyword</code> keyword data.</li><li><code>:long</code> 64 bits wide, two's complement binary</li><li><code>:ref</code> reference to another entity</li><li><code>:string</code> (default) string data</li><li><code>:uri</code> maps to <code>java.net.URI</code></li><li><code>:uuid</code> maps to <code>java.util.UUID</code></li></ul></div><div><span id="ref"></span><h3>3.4 &nbsp;&nbsp; :ref</h3></div><div><p>If the <code>:type</code> is of <code>:ref</code>, the additional customisations are required with the <code>:ref</code> attribute. The treatment of <code>:ref</code>s as well as a more natural reverse search syntax allows more control over the original datomic syntax.</p><ul><li><code>:ns</code> main namespace of the reference to the entity</li><li><code>:rval</code> the name of the back reference</li></ul></div><div><p>An example can be seen below where account has references to books and books also has references to account by pluralizing:</p></div><div class="code"><pre><code class="clojure">(datomic/schema {:account {:book [{:type :ref
                               :ref {:ns :book}}]}
                 :book {:name [{}]}})
;;=&gt; #schema{:account {:book :&amp;book}, :book {:name :string, :accounts :&amp;account&lt;*&gt;}}</code></pre></div><div><p>The reverse reference can be explicitly be set via <code>:rval</code>:</p></div><div class="code"><pre><code class="clojure">(datomic/schema {:account {:book [{:type :ref
                               :ref {:ns :book
                                     :rval :users}}]}
             :book {:name [{}]}})
;;=&gt; #schema{:account {:book :&amp;book}, :book {:name :string, :users :&amp;account&lt;*&gt;}}</code></pre></div><div><p>The reference can refer to it's own namespace:</p></div><div class="code"><pre><code class="clojure">(datomic/schema {:node/next [{:type :ref
                          :ref {:ns :node
                                :rval :previous}}]})
;;=&gt; #schema{:node {:next :&amp;node, :previous :&amp;node&lt;*&gt;}}</code></pre></div><div><p>Reference to it's own without an <code>:rval</code> adds <code>&#95;of</code> when generating the reference reference:</p></div><div class="code"><pre><code class="clojure">(datomic/schema {:node/link   [{:type :ref
                            :ref {:ns :node}}]
             :node/parent [{:type :ref
                            :ref {:ns :node}}]})
;;=&gt; #schema{:node {:link :&amp;node
;;           :parent :&amp;node
;;           :link_of :&amp;node&lt;*&gt;
;;           :parent_of :&amp;node&lt;*&gt;}}</code></pre></div><div><p>Multiple references to the same namespace can also be differentiated automatically:</p></div><div class="code"><pre><code class="clojure">(datomic/schema {:account {:like [{:type :ref
                               :ref {:ns :book}}]
                       :dislike [{:type :ref
                               :ref {:ns :book}}]}
             :book {:name [{}]}})
;;=&gt; #schema{:account {:like :&amp;book, :dislike :&amp;book},
;;           :book {:name :string,
;;                  :like_accounts :&amp;account&lt;*&gt;,
;;                  :dislike_accounts :&amp;account&lt;*&gt;}}</code></pre></div><div><span id="enum"></span><h3>3.5 &nbsp;&nbsp; :enum</h3></div><div><p>If the <code>:type</code> is of <code>:enum</code>, then additional customisations are required with the <code>:enum</code> attribute:</p><ul><li><code>:ns</code> namespace for enum values</li><li><code>:values</code> possible values for enum</li></ul></div><div class="code"><pre><code class="clojure">{:account/type     [{:type :enum
                     :enum {:ns :account.type
                            :values #{:admin :free :paid}}}]}</code></pre></div><div><p>Internally, the data types stored are refs to entities with ids: <code>:account.type/admin</code>, <code>:account.type/free</code> and <code>:account.type/paid</code>.</p></div><div><span id="cardinality"></span><h3>3.6 &nbsp;&nbsp; :cardinality</h3></div><div><p>Specifies whether an attribute associates a single value or a set of values with an entity. The values allowed are:</p><ul><li><code>:one</code> (default) associates a single value with an entity</li><li><code>:many</code> associates a set of values with an entity</li></ul></div><div><span id="unique"></span><h3>3.7 &nbsp;&nbsp; :unique</h3></div><div><p>Specifies a uniqueness constraint for the values of an attribute. Setting an attribute <code>:unique</code> also implies <code>:index</code>. The values allowed for are:</p><ul><li><code>:value</code> only one entity can have a given value for this attribute</li><li><code>:identity</code> attempts to insert a duplicate value for a temporary entity id will cause all attributes associated with that temporary id to be merged with the entity</li><li><code>nil</code> (default)</li></ul></div><div><span id="doc"></span><h3>3.8 &nbsp;&nbsp; :doc</h3></div><div><p>Specifies a documentation string for the attribute</p></div><div class="code"><pre><code class="clojure">(datomic/schema {:node/link   [{:type :ref
                            :doc &quot;The link to the next node&quot;
                            :ref {:ns :node}}]})
;;=&gt; #schema{:node {:link :&amp;node, :link_of :&amp;node&lt;*&gt;}}</code></pre></div><div><span id="index"></span><h3>3.9 &nbsp;&nbsp; :index</h3></div><div><p>Specifies a boolean value indicating that an index should be generated for this attribute. Defaults to <code>false</code></p></div><div><span id="fulltext"></span><h3>3.10 &nbsp;&nbsp; :fulltext</h3></div><div><p>Specifies a boolean value indicating that an eventually consistent fulltext search index should be generated for the attribute. Defaults to <code>false</code></p></div><div><span id="is-component"></span><h3>3.11 &nbsp;&nbsp; :isComponent</h3></div><div><p>Specifies a boolean value indicating that an attribute whose type is <code>:ref</code> refers to a subcomponent of the entity to which the attribute is applied. When you retract an all subcomponents are also retracted. When you touch an entity, all its subcomponent entities are touched recursively. Defaults to false.</p></div><div><span id="no-history"></span><h3>3.12 &nbsp;&nbsp; :noHistory</h3></div><div><p>Specifies a boolean value indicating whether past values of an attribute should not be retained.</p></div><div><span id="required"></span><h3>3.13 &nbsp;&nbsp; :required</h3></div><div><p>Specifies a boolean value indicating that that when data is inserted, that the entry exists. Does not matter for update and query. See <a href='./spirit-walkthrough.html#step-one'>walkthrough</a> for example.</p></div><div><span id="restrict"></span><h3>3.14 &nbsp;&nbsp; :restrict</h3></div><div><p>Specifies a vector, the first being a readable message, the second being the predicate. Like <code>:required</code>, only works for data insertion. See <a href='./spirit-walkthrough.html#step-one'>walkthrough</a> for example.</p></div><div><span id="default"></span><h3>3.15 &nbsp;&nbsp; :default</h3></div><div><p>Specifies a value that will be inserted if nothing is specified. See <a href='./spirit-walkthrough.html#step-one'>walkthrough</a> for example.</p></div><div><span id="connection-params"></span><h2><b>4 &nbsp;&nbsp; Connection Params</b></h2></div><div><span id="connection"></span><h3>4.1 &nbsp;&nbsp; :connection</h3></div><div><span id="creating-a-datastore"></span><h3><i>4.1.1 &nbsp;&nbsp; creating a datastore</i></h3></div><div><p>When <code>connect!</code> is called, it returns a datastore represented as a map containing entries for <code>:connection</code> and <code>:schema</code>:</p></div><div class="code"><pre><code class="clojure">(def schema-connection
  {:book {:name    [{:required true
                     :fulltext true}]
          :author  [{:fulltext true}]}})


(def ds-1 (datomic/connect! &quot;datomic:mem://datomic-connection-1&quot; schema-connection true true))</code></pre></div><div class="code"><pre><code class="clojure">(println ds-1)
;;=&gt; #spirit{:connection #connection{1000 #inst &quot;2016-03-15T12:47:10.039-00:00&quot;},
;;        :schema     #schema{:book {:name :string, :author :string}}}</code></pre></div><div><span id="more-datastores"></span><h3><i>4.1.2 &nbsp;&nbsp; more datastores</i></h3></div><div><p><code>:connection</code> is a reserved keyword in options. We can show how this works by creating two more datastores:</p></div><div class="code"><pre><code class="clojure">(def ds-2 (datomic/connect! &quot;datomic:mem://datomic-connection-2&quot; schema-connection true true))

(def ds-3 (datomic/connect! &quot;datomic:mem://datomic-connection-3&quot; schema-connection true true))</code></pre></div><div><p>Passing a value for <code>:connection</code> will change the connection object that is used. This shouldn't be used very frequently but the feature is there to be exploited. To highlight this, a standard call to <code>insert!</code> is made:</p></div><div class="code"><pre><code class="clojure">(datomic/insert! ds-1 {:book/name &quot;Orpheus&quot;})
=&gt; (contains {:book {:name &quot;Orpheus&quot;}, :db map?})</code></pre></div><div><span id="key--value-input"></span><h3><i>4.1.3 &nbsp;&nbsp; key/value input</i></h3></div><div><p>Lets see the different ways that the <code>:connection</code> entry can be overwritten, first via key/value pair:</p></div><div class="code"><pre><code class="clojure">(datomic/insert! ds-1 {:book/name &quot;Ulysses&quot;} :connection (:connection ds-2))
=&gt; (contains {:book {:name &quot;Ulysses&quot;}, :db map?})</code></pre></div><div><span id="map-input"></span><h3><i>4.1.4 &nbsp;&nbsp; map input</i></h3></div><div><p>The arguments can also be passed in as part of a map:</p></div><div class="code"><pre><code class="clojure">(datomic/insert! ds-1  {:book/name &quot;Eurydice&quot;} {:connection (:connection ds-3)})
=&gt; (contains {:book {:name &quot;Eurydice&quot;}, :db map?})</code></pre></div><div><span id="different-sinks"></span><h3><i>4.1.5 &nbsp;&nbsp; different sinks</i></h3></div><div><p>It can be seen that each datastore has a book of their own:</p></div><div class="code"><pre><code class="clojure">(datomic/select ds-1 :book)
=&gt; #{{:book {:name &quot;Orpheus&quot;}}}


(datomic/select ds-2 :book)
=&gt; #{{:book {:name &quot;Ulysses&quot;}}}

(datomic/select ds-3 :book)
=&gt; #{{:book {:name &quot;Eurydice&quot;}}}</code></pre></div><div><span id="update-example"></span><h3><i>4.1.6 &nbsp;&nbsp; update example</i></h3></div><div><p>Examples below show overwriting of <code>:connection</code> for top level operations such as <code>update!</code></p></div><div class="code"><pre><code class="clojure">(datomic/update! ds-1 :book {:book/name &quot;Medea&quot;} (select-keys ds-3 [:connection]))
(datomic/select ds-3 :book)
=&gt; #{{:book {:name &quot;Medea&quot;}}}</code></pre></div><div><span id="delete-example"></span><h3><i>4.1.7 &nbsp;&nbsp; delete example</i></h3></div><div><p>An example for <code>delete!</code> has alse beeen shown:</p></div><div class="code"><pre><code class="clojure">(datomic/delete! (assoc ds-1 :connection (:connection ds-3)) :book)
(datomic/select ds-3 :book)
=&gt; #{}</code></pre></div><div><span id="db"></span><h3>4.2 &nbsp;&nbsp; :db</h3></div><div><p>For searches (<code>select</code>), instead of specifying a <code>:connection</code> entry, a <code>:db</code> entry can be passed. The following are equivalent calls:</p></div><div class="code"><pre><code class="clojure">(datomic/select ds-1 :book)
=&gt; #{{:book {:name &quot;Orpheus&quot;}}}</code></pre></div><div><span id="key--value-input-0"></span><h3><i>4.2.1 &nbsp;&nbsp; key/value input</i></h3></div><div><p><code>:db</code> passed in as args</p></div><div class="code"><pre><code class="clojure">(datomic/select ds-1 :book :db (raw/db (:connection ds-1)))
=&gt; #{{:book {:name &quot;Orpheus&quot;}}}</code></pre></div><div><span id="map-input-0"></span><h3><i>4.2.2 &nbsp;&nbsp; map input</i></h3></div><div><p><code>:db</code> passed in as a map</p></div><div class="code"><pre><code class="clojure">(datomic/select ds-1 :book {:db (raw/db (:connection ds-1))})
=&gt; #{{:book {:name &quot;Orpheus&quot;}}}</code></pre></div><div><span id="overwriting"></span><h3><i>4.2.3 &nbsp;&nbsp; overwriting</i></h3></div><div><p>Like <code>:connection</code>, the entry for <code>:db</code> can be something completely unrelated to the original <code>:db</code> object, in this case, we are searching on <code>ds-2</code>:</p></div><div class="code"><pre><code class="clojure">(datomic/select ds-1 :book {:db (raw/db (:connection ds-2))})
=&gt; #{{:book {:name &quot;Ulysses&quot;}}}</code></pre></div><div><span id="at"></span><h3>4.3 &nbsp;&nbsp; :at</h3></div><div><span id="time-travel"></span><h3><i>4.3.1 &nbsp;&nbsp; time travel</i></h3></div><div><p><a href='http://www.datomic.com/'>datomic</a> allows searching of the database at any point in time. This functionality is accessible through the <code>:at</code> keyword. We can see this in action:</p></div><div class="code"><pre><code class="clojure">(datomic/select ds-1 :book :at 0)
=&gt; #{}</code></pre></div><div><span id="syntactic-sugar"></span><h3><i>4.3.2 &nbsp;&nbsp; syntactic sugar</i></h3></div><div><p><code>:at</code> makes the intent more clear. The previous statement is equivalent to:</p></div><div class="code"><pre><code class="clojure">(datomic/select ds-1 :book {:db (-&gt; (:connection ds-1)
                                (raw/db) 
                                (raw/as-of 0))})
=&gt; #{}</code></pre></div><div><span id="transaction-id"></span><h3><i>4.3.3 &nbsp;&nbsp; transaction id</i></h3></div><div><p>We can query the datastore after the first transaction has occured, by using an id of <code>1001</code> to access the datastore.</p></div><div class="code"><pre><code class="clojure">(datomic/select ds-1 :book :at 1001)
=&gt; #{{:book {:name &quot;Orpheus&quot;}}}</code></pre></div><div><p>Again, this is equivalent to:</p></div><div class="code"><pre><code class="clojure">(datomic/select ds-1 :book {:db (-&gt; (:connection ds-1)
                                (raw/db) 
                                (raw/as-of 1001))})
=&gt; #{{:book {:name &quot;Orpheus&quot;}}}</code></pre></div><div><span id="transaction-time"></span><h3><i>4.3.4 &nbsp;&nbsp; transaction time</i></h3></div><div><p>We can query the datastore after the first transaction has occured through the time parameter:</p></div><div class="code"><pre><code class="clojure">(:connection ds-1)
;;=&gt; #connection{1001 #inst &quot;2016-03-15T19:13:37.085-00:00&quot;}

(datomic/select ds-1 :book :at #inst &quot;2016-03-15T19:13:00.000-00:00&quot;)
;;=&gt; #{}

(datomic/select ds-1 :book :at #inst &quot;2016-03-15T19:14:00.000-00:00&quot;)
;;=&gt; #{{:book {:name &quot;Orpheus&quot;}}}</code></pre></div><div><span id="mix-and-match"></span><h3><i>4.3.5 &nbsp;&nbsp; mix and match</i></h3></div><div><p>The <code>:at</code> entry can be used in conjunction with <code>:db</code>:</p></div><div class="code"><pre><code class="clojure">(datomic/select ds-1 :book {:db (raw/db (:connection ds-2))
                        :at 0})
=&gt; #{}</code></pre></div><div><p>as well as <code>:connection</code>:</p></div><div class="code"><pre><code class="clojure">(datomic/select ds-1 :book {:connection (:connection ds-2)
                        :at 1001})
=&gt; #{{:book {:name &quot;Ulysses&quot;}}}</code></pre></div><div><span id="return"></span><h3>4.4 &nbsp;&nbsp; :return</h3></div><div><p><code>:return</code> determines the data that has been queried. This is only for <code>select</code> and there are three options available:</p><ul><li><code>:ids</code></li><li><code>:entities</code></li><li><code>:data</code></li></ul></div><div><span id="ids"></span><h3><i>4.4.1 &nbsp;&nbsp; :ids</i></h3></div><div><p>Returns the set of datomic ids that matches the query;</p></div><div class="code"><pre><code class="clojure">(datomic/select ds-1 :book :return :ids)
=&gt; #{17592186045418}</code></pre></div><div><span id="entities"></span><h3><i>4.4.2 &nbsp;&nbsp; :entities</i></h3></div><div><p>Returns the set of datomic entities that matches the query;</p></div><div class="code"><pre><code class="clojure">(-&gt; (datomic/select ds-1 :book :return :entities)
    first
    :db/id)
=&gt; 17592186045418</code></pre></div><div><span id="data"></span><h3><i>4.4.3 &nbsp;&nbsp; :data</i></h3></div><div><p>The default option, returns actual data that can be governed by entries in <code>:pull</code> and <code>:pipeline</code></p></div><div class="code"><pre><code class="clojure">(datomic/select ds-1 :book :return :data)
=&gt; #{{:book {:name &quot;Orpheus&quot;}}}</code></pre></div><div><span id="transact-0"></span><h3>4.5 &nbsp;&nbsp; :transact</h3></div><div><p><code>:transact</code> determines how the results of the call is returned to the caller. This is an important to tune for mutation operations to place emphasis on correctness or speed. There are four options available:</p><ul><li><code>:resolve</code></li><li><code>:datomic</code></li><li><code>:promise</code></li><li><code>:async</code></li></ul></div><div><span id="resolve"></span><h3><i>4.5.1 &nbsp;&nbsp; :resolve</i></h3></div><div><p>This is the default option and takes the longest time. Ensures that that generated temporary ids are resolved and that the data can be used in further transactions:</p></div><div class="code"><pre><code class="clojure">(datomic/insert! ds-1 {:book/name &quot;The Magic School Bus&quot;} {:transact :resolve})
;;=&gt; {:book {:name &quot;The Magic School Bus&quot;},
;;    :db {:id 17592186045432}}</code></pre></div><div><span id="datomic"></span><h3><i>4.5.2 &nbsp;&nbsp; :datomic</i></h3></div><div><p>Waits for the result of the transaction to come back before returning the results:</p></div><div class="code"><pre><code class="clojure">(datomic/insert! ds-1 {:book/name &quot;The Magic School Bus&quot;} {:transact :datomic})
;;=&gt; {:db-before #db{1007 #inst &quot;2016-03-16T12:23:35.761-00:00&quot;},
;;    :db-after #db{1009 #inst &quot;2016-03-16T12:25:42.566-00:00&quot;},
;;    :tx-data [#datom[13194139534321 50 #inst &quot;2016-03-16T12:25:42.566-00:00&quot; 13194139534321 true]
;;              #datom[17592186045426 63 &quot;The Magic School Bus&quot; 13194139534321 true]],
;;    :tempids {-9223350046901838717 17592186045426}}</code></pre></div><div><span id="promise"></span><h3><i>4.5.3 &nbsp;&nbsp; :promise</i></h3></div><div><p>Wraps datomic's <code>transact</code> call to return a promise:</p></div><div class="code"><pre><code class="clojure">(datomic/insert! ds-1 {:book/name &quot;The Magic School Bus&quot;} {:transact :promise})
;;=&gt; #promise
;;    {:status :ready,
;;     :val {:db-before #db{1005 #inst &quot;2016-03-16T12:23:15.992-00:00&quot;},
;;           :db-after #db{1007 #inst &quot;2016-03-16T12:23:35.761-00:00&quot;},
;;           :tx-data [#datom[13194139534319 50 #inst &quot;2016-03-16T12:23:35.761-00:00&quot; 13194139534319 true]
;;                     #datom[17592186045424 63 &quot;The Magic School Bus&quot; 13194139534319 true]],
;;           :tempids {-9223350048542385808 17592186045424}}}</code></pre></div><div><span id="async"></span><h3><i>4.5.4 &nbsp;&nbsp; :async</i></h3></div><div><p>Wraps datomic's <code>transact-async</code> call to return a promise:</p></div><div class="code"><pre><code class="clojure">(datomic/insert! ds-1 {:book/name &quot;The Magic School Bus&quot;} {:transact :async})
;;=&gt; #promise
;;    {:status :ready,
;;     :val {:db-before #db{1005 #inst &quot;2016-03-16T08:53:44.894-00:00&quot;},
;;           :db-after #db{1007 #inst &quot;2016-03-16T08:53:48.645-00:00&quot;},
;;           :tx-data [#datom[13194139534319 50 #inst &quot;2016-03-16T08:53:48.645-00:00&quot; 13194139534319 true]
;;                     #datom[17592186045424 63 &quot;The Magic School Bus&quot; 13194139534319 true]],
;;           :tempids {-9223350047214995662 17592186045424}}}</code></pre></div><div><span id="simulate"></span><h3>4.6 &nbsp;&nbsp; :simulate</h3></div><div><p>When <code>:simulation</code> is set to <code>true</code>, the transaction proceeds as if it was done, without mutating the actual database:</p></div><div><p>The first call to <code>insert!</code> looks just like any other call:</p></div><div class="code"><pre><code class="clojure">(datomic/insert! ds-1 {:book/name &quot;The Magic School Bus&quot;} :simulate true)
=&gt; {:book {:name &quot;The Magic School Bus&quot;}, :db {:id 17592186045420}}</code></pre></div><div><p>But notice that on the next call, the :db/id stays the same:</p></div><div class="code"><pre><code class="clojure">(datomic/insert! ds-1 {:book/name &quot;The Magic School Bus&quot;} :simulate true)
=&gt; {:book {:name &quot;The Magic School Bus&quot;}, :db {:id 17592186045420}}</code></pre></div><div><p>We can pass <code>:spirit</code> in as an additional parameter to retrieve the entire datastructure for the call:</p></div><div class="code"><pre><code class="clojure">(datomic/insert! ds-1 {:book/name &quot;The Magic School Bus&quot;} :simulate true :spirit)
;; =&gt;#spirit{:tempids ...
;;        :schema #schema{:book {:name :string, :author :string}},
;;        :pipeline nil,
;;        :connection #connection{1001 #inst &quot;2016-03-18T04:13:48.499-00:00&quot;}
;;        :db #db{1001 #inst &quot;2016-03-18T04:13:48.499-00:00&quot;}
;;        :process {... ...},
;;        :options {:spirit true,
;;                  :schema-restrict true,
;;                  :schema-required true,
;;                  :schema-defaults true}}</code></pre></div><div><p>A look at <code>ds-1</code> shows that it has not changed after the <code>insert!</code> calls</p></div><div class="code"><pre><code class="clojure">(:connection ds-1)
;;=&gt; #connection{1001 #inst &quot;2016-03-18T04:13:48.499-00:00&quot;}</code></pre></div><div><p>A call to select shows that the book entry has not been added:</p></div><div class="code"><pre><code class="clojure">(datomic/select ds-1 :book)
=&gt; #{{:book {:name &quot;Orpheus&quot;}}}</code></pre></div><div><span id="schema-params"></span><h2><b>5 &nbsp;&nbsp; Schema Params</b></h2></div><div><span id="schema-0"></span><h3>5.1 &nbsp;&nbsp; :schema</h3></div><div><span id="book"></span><h3><i>5.1.1 &nbsp;&nbsp; book</i></h3></div><div><p><code>:schema</code> is the other part of the datastore that is created when <code>connect!</code> is called. The schema is a powerful ally because it contains information about how data should be related, created and managed. To demonstrate this, a book schema is defined:</p></div><div class="code"><pre><code class="clojure">(def schema-book
   {:book   {:name    [{:required true
                        :fulltext true}]
             :author  [{:fulltext true}]}})</code></pre></div><div><p>A connection is created using the schema:</p></div><div class="code"><pre><code class="clojure">(def book-ds (datomic/connect! &quot;datomic:mem://datomic-schema-book&quot; schema-book true true))</code></pre></div><div><p>A single book is entered:</p></div><div class="code"><pre><code class="clojure">(datomic/insert! book-ds {:book {:name &quot;The Magicians&quot;
                             :author &quot;Lev Grossman&quot;}})</code></pre></div><div><p>And then accessed:</p></div><div class="code"><pre><code class="clojure">(datomic/select book-ds :book)
=&gt; #{{:book {:name &quot;The Magicians&quot;, :author &quot;Lev Grossman&quot;}}}</code></pre></div><div><p>We see that both the name and the author of the book is returned.</p></div><div><span id="partial-schema"></span><h3><i>5.1.2 &nbsp;&nbsp; partial schema</i></h3></div><div><p>However, lets define a partial schema:</p></div><div class="code"><pre><code class="clojure">(def name-schema (datomic/schema {:book {:name  [{:required true}]}}))</code></pre></div><div><p>And make a call to select, passing in the <code>:schema</code> entry</p></div><div class="code"><pre><code class="clojure">(datomic/select book-ds :book :schema name-schema)
=&gt; #{{:book {:name &quot;The Magicians&quot;}}}</code></pre></div><div><p>It can be seen that only the book name is returned.</p></div><div><span id="more-examples"></span><h3><i>5.1.3 &nbsp;&nbsp; more examples</i></h3></div><div><p>By passing in different schemas, an application can allow for isolation of various functionalities as well have as basic protection of data. It can be seen how the two schemas behave. Below shows a normal search on :book/author:</p></div><div class="code"><pre><code class="clojure">(datomic/select book-ds :book/author)
=&gt; #{{:book {:name &quot;The Magicians&quot;, :author &quot;Lev Grossman&quot;}}}</code></pre></div><div><p>Using the abridged schema, an exception is thrown:</p></div><div class="code"><pre><code class="clojure">(datomic/select book-ds :book/author :schema name-schema)
=&gt; (throws)</code></pre></div><div><span id="pull"></span><h3>5.2 &nbsp;&nbsp; :pull</h3></div><div><p>A connection is created using the schema:</p></div><div class="code"><pre><code class="clojure">(def schema-store
   {:book   {:name    [{:required true
                        :fulltext true}]
             :author  [{:fulltext true}]}
    :inventory {:count [{:type :long}]
                :book    [{:type :ref
                           :ref  {:ns :book}}]
                :store   [{:type :ref
                           :ref  {:ns :store
                                  :rval :inventory}}]}
    :store  {:name    [{:required true
                        :fulltext true}]}})

(def store-ds (datomic/connect! &quot;datomic:mem://datomic-schema-store&quot; schema-store true true))</code></pre></div><div><p>A store is created with inventory:</p></div><div class="code"><pre><code class="clojure">(datomic/insert! store-ds
             {:store {:name &quot;Happy Books&quot;
                      :inventory #{{:count 10
                                    :book {:name &quot;The Magicians&quot;
                                           :author &quot;Lev Grossman&quot;}}
                                   {:count 8
                                    :book {:name &quot;The Color of Magic&quot;
                                           :author &quot;Terry Pratchett&quot;}}}}})</code></pre></div><div><span id="defaults"></span><h3><i>5.2.1 &nbsp;&nbsp; defaults</i></h3></div><div><p>The default behaviour for <code>:pull</code> is to grab all attributes from an entity that are not references:</p></div><div class="code"><pre><code class="clojure">(datomic/select store-ds :store)
=&gt; #{{:store {:name &quot;Happy Books&quot;}}}</code></pre></div><div><span id="checked-and-unchecked"></span><h3><i>5.2.2 &nbsp;&nbsp; :checked and :unchecked</i></h3></div><div><p>However, this can be customised by using <code>:checked</code> and <code>:unchecked</code></p></div><div class="code"><pre><code class="clojure">(datomic/select store-ds :store
            :pull {:store {:name :unchecked
                           :inventory :checked}})
=&gt; #{{:store {:inventory #{{:count 8} {:count 10}}}}}</code></pre></div><div><span id="id"></span><h3><i>5.2.3 &nbsp;&nbsp; :id</i></h3></div><div><p>The pull model can be nested and allows very quick customisation of data. Using <code>:id</code> restricts refs to return the internal id:</p></div><div class="code"><pre><code class="clojure">(datomic/select store-ds :store
            :pull {:store {:inventory {:book :id}}}
            :first)
=&gt; {:store {:name &quot;Happy Books&quot;,
            :inventory #{{:count 8, :book 17592186045422}
                         {:count 10, :book 17592186045420}}}}</code></pre></div><div><span id="forward-walk"></span><h3><i>5.2.4 &nbsp;&nbsp; forward walk</i></h3></div><div><p>Using <code>{}</code> for defining the <code>:pull</code> model for a ref is the same as using <code>:checked</code></p></div><div class="code"><pre><code class="clojure">(datomic/select store-ds {:store/name &quot;Happy Books&quot;}
            :pull {:store {:inventory {:book {}}}})
=&gt; #{{:store {:name &quot;Happy Books&quot;,
               :inventory #{{:count 10
                             :book {:name &quot;The Magicians&quot;
                                    :author &quot;Lev Grossman&quot;}}
                            {:count 8
                             :book {:name &quot;The Color of Magic&quot;
                                    :author &quot;Terry Pratchett&quot;}}}}}}</code></pre></div><div><span id="reverse-walk"></span><h3><i>5.2.5 &nbsp;&nbsp; reverse walk</i></h3></div><div><p><code>:pull</code> also works for reverse lookups, having the ability to walk the schema in the opposite direction:</p></div><div class="code"><pre><code class="clojure">(datomic/select store-ds {:book/name '(?fulltext &quot;Magic&quot;)}
            :pull {:book {:inventories {:store :checked}}})
=&gt; #{{:book {:name &quot;The Color of Magic&quot;,
             :author &quot;Terry Pratchett&quot;,
             :inventories #{{:count 8,
                             :store {:name &quot;Happy Books&quot;}}}}}}</code></pre></div><div><span id="yield"></span><h3><i>5.2.6 &nbsp;&nbsp; :yield</i></h3></div><div><p>A special option <code>:yield</code> is available for recursive references. To show this in action, a different datastore is required:</p></div><div class="code"><pre><code class="clojure">(def schema-nodes
   {:node   {:name   [{:required true}]
             :next   [{:type :ref
                       :ref {:ns :node
                             :rval :previous}}]}})

(def node-ds (datomic/connect! &quot;datomic:mem://datomic-schema-nodes&quot; schema-nodes true true))</code></pre></div><div><p>A set of maps are inserted:</p></div><div class="code"><pre><code class="clojure">(datomic/insert! node-ds {:node {:name &quot;A&quot;
                             :next {:name &quot;B&quot;
                                    :next {:name &quot;C&quot;
                                           :next {:name &quot;D&quot;}}}}})</code></pre></div><div><p>We can now perform selection:</p></div><div class="code"><pre><code class="clojure">(datomic/select node-ds {:node/name &quot;B&quot;})
=&gt; #{{:node {:name &quot;B&quot;}}}</code></pre></div><div><p>when <code>:yield</code> is flagged on a ref, the <code>:pull</code> model yields to what was previously defined:</p></div><div class="code"><pre><code class="clojure">(datomic/select node-ds {:node/name &quot;B&quot;}
            :pull {:node {:next :yield}})
=&gt; #{{:node {:name &quot;B&quot;, :next {:name &quot;C&quot;, :next {:name &quot;D&quot;}}}}}</code></pre></div><div><span id="recursion"></span><h3><i>5.2.7 &nbsp;&nbsp; recursion</i></h3></div><div><p>The option is great for arbitrarily linked data. Additionally, the data model can be walked both forwards and backwards</p></div><div class="code"><pre><code class="clojure">(datomic/select node-ds {:node/name &quot;D&quot;}
            :pull {:node {:previous :yield}})
=&gt; #{{:node {:name &quot;D&quot;, :previous #{{:name &quot;C&quot;, :previous #{{:name &quot;B&quot;, :previous #{{:name &quot;A&quot;}}}}}}}}}</code></pre></div><div><p>A mix of <code>:yield</code> and <code>:checked</code> makes for some interesting datastructures</p></div><div class="code"><pre><code class="clojure">(datomic/select node-ds {:node/name &quot;C&quot;}
            :pull {:node {:next :yield
                          :previous :checked}})
=&gt; #{{:node {:name &quot;C&quot;, :next {:name &quot;D&quot;,
                               :previous #{{:name &quot;C&quot;}}},
             :previous #{{:name &quot;B&quot;}}}}}</code></pre></div><div><span id="access"></span><h3>5.3 &nbsp;&nbsp; :access</h3></div><div><p><code>:access</code> provides restrictions on input and an outline on how data should be returned. The following is how it is typically used:</p></div><div class="code"><pre><code class="clojure">(datomic/select node-ds {:node {:name &quot;C&quot;}}
            :access {:node :checked})
=&gt; #{{:node {:name &quot;C&quot;}}}</code></pre></div><div><span id="restrictions"></span><h3><i>5.3.1 &nbsp;&nbsp; restrictions</i></h3></div><div><p>When the selector oversteps what is deemed acceptable, an exception is thrown:</p></div><div class="code"><pre><code class="clojure">(datomic/select node-ds {:node {:next {:name &quot;C&quot;}}}
            :access {:node :checked})
=&gt; (throws)</code></pre></div><div><p>The model is able to follow the data and the returned values:</p></div><div class="code"><pre><code class="clojure">(datomic/select node-ds {:node {:next {:name &quot;C&quot;}}}
            :access {:node {:next :checked}})
=&gt; #{{:node {:name &quot;B&quot;, :next {:name &quot;C&quot;}}}}</code></pre></div><div><p>Reverse lookups are also supported</p></div><div class="code"><pre><code class="clojure">(datomic/select node-ds {:node {:previous {:name &quot;C&quot;}}}
            :access {:node {:previous :checked}})
=&gt; #{{:node {:name &quot;D&quot;, :previous #{{:name &quot;C&quot;}}}}}</code></pre></div><div><span id="combination"></span><h3><i>5.3.2 &nbsp;&nbsp; combination</i></h3></div><div><p><code>:access</code> and <code>:pull</code> can be used to work together to limit data:</p></div><div class="code"><pre><code class="clojure">(datomic/select node-ds {:node {:next {:name &quot;C&quot;}}}
            :access {:node {:next :checked}}
            :pull   {:node :checked})
=&gt; #{{:node {:name &quot;B&quot;}}}</code></pre></div><div><p>or to expand the data that is returned:</p></div><div class="code"><pre><code class="clojure">(datomic/select node-ds {:node {:next {:name &quot;C&quot;}}}
            :access {:node {:next :checked}}
            :pull   {:node {:next {:next :checked}}})
=&gt; #{{:node {:name &quot;B&quot;,
             :next {:name &quot;C&quot;,
                    :next {:name &quot;D&quot;}}}}}</code></pre></div><div><span id="options-0"></span><h2><b>6 &nbsp;&nbsp; Options</b></h2></div><div><p>For demonstration of search options, we define a schema</p></div><div class="code"><pre><code class="clojure">(def schema-school
  {:student   {:name      [{:required true
                            :fulltext true}]
               :classes   [{:type :ref
                            :cardinality :many
                            :ref {:ns   :class}}]}
   :class     {:subject [{:required true}]
               :teacher [{:type :ref
                          :ref {:ns   :teacher
                                :rval :class}}]}
   :teacher   {:name    [{:required true}]
               :age     [{:type :long}]}})</code></pre></div><div><p>The datastore is created:</p></div><div class="code"><pre><code class="clojure">(def school-ds (datomic/connect! &quot;datomic:mem://datomic-options-school-store&quot; schema-school true true))</code></pre></div><div><p>Data is put into the system:</p></div><div class="code"><pre><code class="clojure">(datomic/insert! school-ds
             [{:db/id (datomic/iid :science)
               :class {:subject &quot;Science&quot;
                       :teacher {:name &quot;Mr Michaels&quot;
                                 :age 39}}}
              {:db/id (datomic/iid :math)
               :class {:subject &quot;Math&quot;
                       :teacher {:name &quot;Mr Nolan&quot;
                                 :age 26}}}
              {:student {:name &quot;Charlie&quot;
                         :classes #{(datomic/iid :science)}}}
              {:student {:name &quot;Bob&quot;
                         :classes #{(datomic/iid :math)}}}
              {:student {:name &quot;Anne&quot;
                         :classes #{(datomic/iid :science)
                                    (datomic/iid :math)}}}])</code></pre></div><div><p>And we are ready to go!</p></div><div><span id="first"></span><h3>6.1 &nbsp;&nbsp; :first</h3></div><div><p>Instead of returning a set of values, returns the first element of the results. Useful when only one value is returned:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds {:student/name &quot;Anne&quot;} {:options {:first :true}})
=&gt; {:student {:name &quot;Anne&quot;}}</code></pre></div><div><p>The shorthand can be used:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds {:student/name &quot;Anne&quot;} :first)
=&gt; {:student {:name &quot;Anne&quot;}}</code></pre></div><div><p>Also works when there is more than one possible value:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds :student)
=&gt; #{{:student {:name &quot;Bob&quot;}} {:student {:name &quot;Anne&quot;}} {:student {:name &quot;Charlie&quot;}}}</code></pre></div><div><p>Because <code>Charlie</code> was put in first, we expect that his name comes up first:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds :student :first)
=&gt; {:student {:name &quot;Charlie&quot;}}</code></pre></div><div><span id="ids-0"></span><h3>6.2 &nbsp;&nbsp; :ids</h3></div><div><p>Returns the datomic ids for the piece of data:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds {:student/name &quot;Anne&quot;} {:options {:ids :true}})

=&gt; #{{:student {:name &quot;Anne&quot;}, :db {:id 17592186045424}}}</code></pre></div><div><p><code>:ids</code> work fine with <code>:pull</code>, <code>:access</code> and data related options</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds {:student/name &quot;Anne&quot;}
           :ids
           :pull {:student {:classes {:teacher :checked}}})
  
=&gt; #{{:db {:id 17592186045424}
      :student {:name &quot;Anne&quot;,
                :classes #{{:+ {:db {:id 17592186045420}}
                            :subject &quot;Math&quot;,
                            :teacher {:+ {:db {:id 17592186045421}}
                                      :name &quot;Mr Nolan&quot;
                                      :age 26}}
                           {:+ {:db {:id 17592186045418}}
                            :subject &quot;Science&quot;,
                            :teacher {:+ {:db {:id 17592186045419}}
                                      :name &quot;Mr Michaels&quot;
                                      :age 39}}}}}}</code></pre></div><div><span id="blank"></span><h3>6.3 &nbsp;&nbsp; :blank</h3></div><div><p>works with <code>:pull</code> to specify how refs should be returned:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds {:student/name &quot;Anne&quot;} :blank)
 =&gt; #{{}}</code></pre></div><div><span id="default-setting"></span><h3><i>6.3.1 &nbsp;&nbsp; default setting</i></h3></div><div><p>For default behaviour on queries, this option can be set as default on initialisation:</p></div><div class="code"><pre><code class="clojure">(def blank-ds
  (datomic/connect! {:uri &quot;datomic:mem://datomic-options-school-store&quot;
                     :schema schema-school
                     :options {:blank true}}))</code></pre></div><div class="code"><pre><code class="clojure">(datomic/select blank-ds {:student/name &quot;Anne&quot;})
=&gt; #{{}}</code></pre></div><div><span id="pull-behaviour"></span><h3><i>6.3.2 &nbsp;&nbsp; pull behaviour</i></h3></div><div><p>Once set, the results will only be what the model governed by <code>:pull</code> allows:</p></div><div class="code"><pre><code class="clojure">(datomic/select blank-ds {:student/name &quot;Anne&quot;}
                :pull {:student {:name :checked}})
=&gt; #{{:student {:name &quot;Anne&quot;}}}</code></pre></div><div class="code"><pre><code class="clojure">(datomic/select blank-ds {:student/classes {:teacher/age 39}}
           :pull {:student {:name :checked}})
 =&gt; #{{:student {:name &quot;Anne&quot;}}
    {:student {:name &quot;Charlie&quot;}}}</code></pre></div><div><span id="access-behaviour"></span><h3><i>6.3.3 &nbsp;&nbsp; access behaviour</i></h3></div><div><p><code>:access</code> will also work the same as <code>:pull</code> but with query restrictions</p></div><div class="code"><pre><code class="clojure">(datomic/select blank-ds {:student/name &quot;Anne&quot;}
            :first
            :access {:student {:name :checked}})
=&gt; {:student {:name &quot;Anne&quot;}}</code></pre></div><div class="code"><pre><code class="clojure">(datomic/select blank-ds {:student/classes {:teacher/age 39}}
            :access {:student {:name :checked}})
=&gt; (throws)</code></pre></div><div><span id="ref-traversal"></span><h3><i>6.3.4 &nbsp;&nbsp; ref traversal</i></h3></div><div><p>when a key in a ref is checked, it will return only the data for that particular key</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds {:student/name &quot;Anne&quot;}
            :blank
            :pull {:student {:classes {:teacher {:name :checked}}}})
=&gt; #{{:student {:classes #{{:teacher {:name &quot;Mr Michaels&quot;}}
                           {:teacher {:name &quot;Mr Nolan&quot;}}}}}}</code></pre></div><div><p>when the ref itself is checked, it will return all non ref data</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds {:student/name &quot;Anne&quot;}
           {:options {:blank true}
            :pull {:student {:classes {:teacher :checked}}}})
 =&gt; #{{:student {:classes #{{:teacher {:name &quot;Mr Michaels&quot;, :age 39}}
                          {:teacher {:name &quot;Mr Nolan&quot;, :age 26}}}}}}</code></pre></div><div><span id="ban-expressions"></span><h3>6.4 &nbsp;&nbsp; :ban-expressions</h3></div><div><p>expressions can be used to select</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds {:student/name '(.startsWith ? &quot;A&quot;)})
=&gt; #{{:student {:name &quot;Anne&quot;}}}</code></pre></div><div><p>At times, especially when directly exposing the interface to the outside, it may be a good idea to disable this functionality:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
                {:student/name '(.startsWith ? &quot;A&quot;)}
                :ban-expressions)
=&gt; (throws)</code></pre></div><div><span id="ban-top-id"></span><h3>6.5 &nbsp;&nbsp; :ban-top-id</h3></div><div><p>When there are no restrictions, ids can be used as direct input:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds 17592186045424)
=&gt; #{{:student {:name &quot;Anne&quot;}}}</code></pre></div><div><p>This option disables selection of entity from the very top</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds 17592186045424 :ban-top-id)
=&gt; (throws)</code></pre></div><div><p>However, this does not prevent selection of related data:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds {:class/students 17592186045424} :ban-top-id)
=&gt; #{{:class {:subject &quot;Math&quot;}} {:class {:subject &quot;Science&quot;}}}</code></pre></div><div><span id="ban-body-ids"></span><h3>6.6 &nbsp;&nbsp; :ban-body-ids</h3></div><div><p>The opposite of <code>:ban-top-id</code>. This option disables selection of entity from the query:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds 17592186045424 :ban-body-ids)
#{{:student {:name &quot;Anne&quot;}}}</code></pre></div><div><p>And when numbers are not in the body, an exception is thrown:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:class/students 17592186045424} :ban-body-ids)
=&gt; (throws)</code></pre></div><div><span id="ban-ids"></span><h3>6.7 &nbsp;&nbsp; :ban-ids</h3></div><div><p>The combination of both options. Throws whever it sees an id:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds 17592186045424 :ban-ids)
=&gt; (throws)</code></pre></div><div><p>And when numbers are not in the body, an exception is thrown:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:class/students 17592186045424} :ban-ids)
=&gt; (throws)</code></pre></div><div><span id="raw"></span><h3>6.8 &nbsp;&nbsp; :raw</h3></div><div><p>Returns the actual input that would be given to datomic:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:class/students 17592186045424} :raw)
;;=&gt; [:find ?self :where [17592186045424 :student/classes ?self]]</code></pre></div><div><p>Works for both queries and datoms:</p></div><div class="code"><pre><code class="clojure">(datomic/insert! school-ds
             [{:db/id (datomic/iid :science)
               :class {:subject &quot;Science&quot;
                       :teacher {:name &quot;Mr Michaels&quot;
                                 :age 39}}}
              {:db/id (datomic/iid :math)
               :class {:subject &quot;Math&quot;
                       :teacher {:name &quot;Mr Nolan&quot;
                                 :age 26}}}
              {:student {:name &quot;Charlie&quot;
                         :classes #{(datomic/iid :science)}}}
              {:student {:name &quot;Bob&quot;
                         :classes #{(datomic/iid :math)}}}
              {:student {:name &quot;Anne&quot;
                         :classes #{(datomic/iid :science)
                                    (datomic/iid :math)}}}]
             :raw)
;;=&gt; [{:db/id #spirit[:science]
;;     :class/subject &quot;Science&quot;}
;;     :class/teacher {:db/id #spirit[?e262028]
;;                     :teacher/name &quot;Mr Michaels&quot;
;;                     :teacher/age 39}} 
;;    {:db/id #spirit[:math]
;;     :class/subject &quot;Math&quot;
;;     :class/teacher {:db/id #spirit[?e262029]
;;                     :teacher/name &quot;Mr Nolan&quot;
;;                     :teacher/age 26}}
;;    {:student/name &quot;Charlie&quot;, :db/id #spirit[?e262030]}
;;    [:db/add #spirit[?e262030] :student/classes #spirit[:science]]
;;    {:student/name &quot;Bob&quot;, :db/id #spirit[?e262031]}
;;    [:db/add #spirit[?e262031] :student/classes #spirit[:math]]
;;    {:student/name &quot;Anne&quot;, :db/id #spirit[?e262032]}
;;    [:db/add #spirit[?e262032] :student/classes #spirit[:science]]
;;    [:db/add #spirit[?e262032] :student/classes #spirit[:math]])</code></pre></div><div><span id="spirit"></span><h3>6.9 &nbsp;&nbsp; :spirit</h3></div><div><p>Returns the <code>spirit</code> datastructure used for the query, useful for debugging. This map has all the acculmulated data as the query/insert moves through the spirit data pipeline</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds {:class/students 17592186045424} :spirit)
;;=&gt; #spirit{:tempids {:status :ready, :val #{}},
;;        :schema #schema{:student {:name :string,
;;                                  :classes :&amp;class&lt;*&gt;},
;;                        :class   {:subject :string,
;;                                  :teacher :&amp;teacher,
;;                                  :students :&amp;student&lt;*&gt;},
;;                        :teacher {:name :string,
;;                                  :age :long,
;;                                  :class :&amp;class&lt;*&gt;}}
;;        :pipeline nil,
;;        :db #db{1001 #inst &quot;2016-03-18T06:14:23.156-00:00&quot;},
;;        :process {:input
;;                  {:class/students 17592186045424},
;;
;;                  :normalised
;;                  {:class {:students #{17592186045424}}}
;;
;;                  :analysed
;;                  {:# {:sym ?self, :id ?e262444}
;;                   :class/students #{17592186045424}}
;;
;;                  :reviewed
;;                  {:# {:sym ?self, :id ?e262444}
;;                   :class/students #{17592186045424}}
;;
;;                  :characterised
;;                  {:# {:sym ?self, :id ?e262444}
;;                   :rev-ids-many {:student/classes #{}}
;;                   :rev-ids {:student/classes #{17592186045424}}
;;
;;                  :emitted
;;                  [:find ?self :where
;;                   [17592186045424 :student/classes ?self]]},
;;        :type &quot;query&quot;,
;;        :op :select,
;;        :result {:ids (17592186045418 17592186045420),
;;                 :entities ({:db/id 17592186045418}
;;                            {:db/id 17592186045420}),
;;                 :data ({:class {:subject &quot;Science&quot;}}
;;                        {:class {:subject &quot;Math&quot;}})}
;;        :options {:spirit true},
;;        :connection #connection{1001 #inst &quot;2016-03-18T06:14:23.156-00:00&quot;}}</code></pre></div><div><span id="pipeline-0"></span><h2><b>7 &nbsp;&nbsp; Pipeline</b></h2></div><div><p>The data pipeline is used for preprocessing of incoming data before accessing datomic. Different stages of the pipeline can be seen below:</p></div><div class="figure"><a id="img-img--spirit-pipeline-png"></a><div class="img"><img line="{:row 278, :col 1, :end-row 278, :end-col 59}" src="img/spirit-pipeline.png" width="250px" /></div><p></p></div><div><span id="pre-process"></span><h3>7.1 &nbsp;&nbsp; :pre-process</h3></div><div><p>Manipulation of the datastructure before going into the pipeline. Takes one function the first the data structure</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:student/name &quot;Charlie&quot;}
            {:pipeline {:pre-process
                        (fn [x]
                          (assoc-in x [:student :name] &quot;Bob&quot;))}})
=&gt; #{{:student {:name &quot;Bob&quot;}}}</code></pre></div><div><p>Different options can be passed into the datastore through a second optional param: the datastore object:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:student/name &quot;Charlie&quot;}
            {:pipeline {:pre-process
                        (fn [x spirit]
                          (assoc-in x [:student :name]
                                    (-&gt; spirit :params :name)))}
             :params {:name &quot;Bob&quot;}})
=&gt; #{{:student {:name &quot;Bob&quot;}}}</code></pre></div><div><span id="pre-require"></span><h3>7.2 &nbsp;&nbsp; :pre-require</h3></div><div><p>Checks to see if data in a certain field is availiable:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:student/name &quot;Charlie&quot;}
            {:pipeline {:pre-require
                        {:student {:name :checked}}}})
=&gt; #{{:student {:name &quot;Charlie&quot;}}}</code></pre></div><div><p>If it is not, then the operation throws an error:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:student/classes {:subject &quot;Math&quot;}}
            {:pipeline {:pre-require
                        {:student {:name :checked}}}})
=&gt; (throws)</code></pre></div><div><p>The fields are accessed in a nested fashion:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:student/classes {:subject &quot;Math&quot;}}
            {:pipeline {:pre-require
                        {:student
                         {:classes {:subject (fn [_ _] true)}}}}})
=&gt; #{{:student {:name &quot;Bob&quot;}}
     {:student {:name &quot;Anne&quot;}}}</code></pre></div><div><span id="pre-mask"></span><h3>7.3 &nbsp;&nbsp; :pre-mask</h3></div><div><p>Removes an entry in the map. For example, it is currently the case that a search for student named Charlie that takes Math class does not yield any results:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:student {:name &quot;Charlie&quot;
                       :classes {:subject &quot;Math&quot;}}})
=&gt; #{}</code></pre></div><div><p>However, we can mask the data, in this case, taking out the value for <code>:student/name</code> to only search for students that are taking Math class.</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:student {:name &quot;Charlie&quot;
                       :classes {:subject &quot;Math&quot;}}}
            {:pipeline {:pre-mask
                        {:student {:name :checked}}}})
=&gt; #{{:student {:name &quot;Bob&quot;}}
     {:student {:name &quot;Anne&quot;}}}</code></pre></div><div><p>This example shows the class subject being masked:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:student {:name &quot;Charlie&quot;
                       :classes {:subject &quot;Math&quot;}}}
            {:pipeline {:pre-mask
                        {:student
                         {:classes {:subject (fn [_ _] true)}}}}})
=&gt; #{{:student {:name &quot;Charlie&quot;}}}</code></pre></div><div><span id="pre-transform"></span><h3>7.4 &nbsp;&nbsp; :pre-transform</h3></div><div><p>Applies a transformation directly to the value, takes a function containing the value as well as the spirit datastructure:</p></div><div class="code"><pre><code class="clojure">(defn capitalise [x]
  (str (.toUpperCase (str (first x)))
       (.toLowerCase (apply str (rest x)))))</code></pre></div><div><p>Takes one or two arguments, like <code>pre-process</code>:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:student {:name &quot;Charlie&quot;
                       :classes {:subject &quot;SCIENCE&quot;}}}
            {:pipeline {:pre-transform
                        {:student
                         {:classes
                          {:subject capitalise}}}}})
=&gt; #{{:student {:name &quot;Charlie&quot;}}}</code></pre></div><div><p>A more explicit version where capitalise is passed in is shown:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:student {:name &quot;Charlie&quot;
                       :classes {:subject &quot;SCIENCE&quot;}}}
            {:fn capitalise
             :pipeline {:pre-transform
                        {:student
                         {:classes
                          {:subject
                           (fn [x spirit]
                             ((:fn spirit) x))}}}}})
=&gt; #{{:student {:name &quot;Charlie&quot;}}}</code></pre></div><div><span id="fill-empty"></span><h3>7.5 &nbsp;&nbsp; :fill-empty</h3></div><div><p>Makes sure that if a value is empty, then it will be filled either by a value</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {}
            {:pipeline {:fill-empty
                        {:student {:classes
                                   {:subject &quot;Science&quot;}}}}})
=&gt; #{{:student {:name &quot;Anne&quot;}} {:student {:name &quot;Charlie&quot;}}}</code></pre></div><div><p>Or a function:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {}
            {:params {:subject &quot;Science&quot;}
             :pipeline {:fill-empty
                        {:student
                         {:classes
                          {:subject (fn [x]
                                      &quot;Science&quot;)}}}}})
=&gt; #{{:student {:name &quot;Anne&quot;}} {:student {:name &quot;Charlie&quot;}}}</code></pre></div><div><p>Again, like previous pipeline segments values can be passed in:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {}
            {:params {:subject &quot;Science&quot;}
             :pipeline {:fill-empty
                        {:student
                         {:classes
                          {:subject
                           (fn [_ spirit]
                             (-&gt; spirit :params :subject))}}}}})
=&gt; #{{:student {:name &quot;Anne&quot;}} {:student {:name &quot;Charlie&quot;}}}</code></pre></div><div><span id="fill-assoc"></span><h3>7.6 &nbsp;&nbsp; :fill-assoc</h3></div><div><p>Makes sure that additional values are added, in this case, we have imposed an additional restriction that the student should be taking Math as well as Science:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:student {:classes
                       {:subject &quot;Science&quot;}}}
            {:pipeline {:fill-assoc
                        {:student
                         {:classes #{{:subject &quot;Math&quot;}}}}}})
=&gt; #{{:student {:name &quot;Anne&quot;}}}</code></pre></div><div><p>Use of a function is also valid:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:student {:classes
                       {:subject &quot;Science&quot;}}}
            {:pipeline {:fill-assoc
                        {:student
                         {:classes
                          (fn [_] {:subject &quot;Math&quot;})}}}})
=&gt; #{{:student {:name &quot;Anne&quot;}}}</code></pre></div><div><p>Note that this will not work:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:student {:classes
                       {:subject &quot;Science&quot;}}}
            {:pipeline {:fill-assoc
                        {:student
                         {:classes
                          {:subject &quot;Math&quot;}}}}})
=&gt; #{}</code></pre></div><div><p>This is because of the generated search query. As can be seen, for the previous case, the query generates a statement where we need to find a subject that has both <code>Science</code> and <code>Math</code> as names (which is impossible)</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:student {:classes
                       {:subject #{&quot;Math&quot; &quot;Science&quot;}}}}
            :raw)
=&gt; [:find ?self :where
    [?self :student/classes ?e160221]
    [?e160221 :class/subject &quot;Science&quot;]
    [?e160221 :class/subject &quot;Math&quot;]]</code></pre></div><div><p>Whereas the correct way, is to say that the student takes two different classes, whose names are <code>Math</code> for the first and <code>Science</code> for the second:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:student {:classes
                       #{{:subject &quot;Science&quot;}
                         {:subject &quot;Math&quot;}}}}
            :raw)
=&gt; [:find ?self :where
    [?self :student/classes ?e160225]
    [?self :student/classes ?e160226]
    [?e160225 :class/subject &quot;Math&quot;]
    [?e160226 :class/subject &quot;Science&quot;]]</code></pre></div><div><span id="ignore"></span><h3>7.7 &nbsp;&nbsp; :ignore</h3></div><div><p>Sometimes, there is data that is not in the schema, resulting in an exception being thrown:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:student {:rating 10
                       :classes {:subject &quot;Science&quot;}}})
=&gt; (throws)</code></pre></div><div><p>Having <code>:ignore</code> params makes sure that the extra entries do not raise any issues</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:student {:rating 10
                       :classes
                       #{{:subject &quot;Science&quot;}}}}
            {:pipeline {:ignore
                        {:student {:rating :checked}}}})
=&gt; #{{:student {:name &quot;Anne&quot;}} {:student {:name &quot;Charlie&quot;}}}</code></pre></div><div><span id="allow"></span><h3>7.8 &nbsp;&nbsp; :allow</h3></div><div><p>Allows only entries that have been specified:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:student {:classes
                       #{{:subject &quot;Science&quot;}}}}
            {:pipeline {:allow
                        {:student
                         {:classes {:subject :checked}}}}})
=&gt; #{{:student {:name &quot;Anne&quot;}}
     {:student {:name &quot;Charlie&quot;}}}</code></pre></div><div><p>If there is a search on entries that are not allowed, an exception will be thrown:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:student/name &quot;Anne&quot;}
            {:pipeline {:allow
                        {:student
                         {:classes {:subject :checked}}}}})
=&gt; (throws)</code></pre></div><div><p>When the map is empty, everything is restricted:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:student {:classes
                       #{{:subject &quot;Science&quot;}}}}
            {:pipeline {:allow {}}})
=&gt; (throws)</code></pre></div><div><span id="validate"></span><h3>7.9 &nbsp;&nbsp; :validate</h3></div><div><p>Validates the map using a function of two parameters:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:student/name &quot;Anne&quot;}
            {:validate {:name &quot;Anne&quot;}
             :pipeline {:validate
                        {:student
                         {:name
                          (fn [x spirit]
                            (= x
                               (-&gt; spirit :validate :name)))}}}})
=&gt; #{{:student {:name &quot;Anne&quot;}}}</code></pre></div><div><p>If the validation fails, an exception is thrown:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:student/name &quot;Anne&quot;}
            {:pipeline {:validate
                        {:student
                         {:name (fn [x _] (not= &quot;Anne&quot; x))}}}})
=&gt; (throws)</code></pre></div><div><span id="convert"></span><h3>7.10 &nbsp;&nbsp; :convert</h3></div><div><p>Same as the <code>pre</code> and <code>post</code> transforms, just another place in the pipeline where a generic function can be used:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:student/name &quot;anne&quot;}
            {:pipeline {:convert
                        {:student {:name capitalise}}}})
=&gt; #{{:student {:name &quot;Anne&quot;}}}</code></pre></div><div><p>Works with one or two arguments:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:student/name &quot;anne&quot;}
            {:fn capitalise
             :pipeline {:convert
                        {:student
                         {:name (fn [x spirit]
                                  ((:fn spirit) x))}}}})
=&gt; #{{:student {:name &quot;Anne&quot;}}}</code></pre></div><div><span id="post-require"></span><h3>7.11 &nbsp;&nbsp; :post-require</h3></div><div><p>Same as <code>:pre-require</code> but happens later in the pipeline:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:student {:classes {:subject &quot;Math&quot;}}}
            {:pipeline {:fill-assoc
                        {:student {:name &quot;Bob&quot;}}
                        :post-require
                        {:student {:name :checked}}}})
=&gt; #{{:student {:name &quot;Bob&quot;}}}</code></pre></div><div><p>It can be seen that if the above statement was replaced with <code>:pre-require</code>, an exception would be thrown because <code>:fill-assoc</code> occurs after <code>:post-require</code> but before <code>:post-require</code>. Since that particular stage has not been run, the require check shows an empty entry:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:student {:classes {:subject &quot;Math&quot;}}}
            {:pipeline {:fill-assoc
                        {:student {:name &quot;Bob&quot;}}
                        :pre-require
                        {:student {:name :checked}}}})
=&gt; (throws)</code></pre></div><div><span id="post-mask"></span><h3>7.12 &nbsp;&nbsp; :post-mask</h3></div><div><p>Like <code>:pre-mask</code>, but occurs after the validation and fill stages:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:student {:classes {:subject &quot;Math&quot;}}}
            {:pipeline {:fill-assoc {:student {:name &quot;Bob&quot;}}
                        :post-mask
                        {:student {:name (fn [_] true)}}}})
=&gt; #{{:student {:name &quot;Bob&quot;}}
     {:student {:name &quot;Anne&quot;}}}</code></pre></div><div><p>Compared to what happens when using <code>:pre-mask</code>:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:student {:classes {:subject &quot;Math&quot;}}}
            {:pipeline {:fill-assoc {:student {:name &quot;Bob&quot;}}
                        :pre-mask
                        {:student {:name :checked}}}})
=&gt; #{{:student {:name &quot;Bob&quot;}}}</code></pre></div><div><span id="post-transform"></span><h3>7.13 &nbsp;&nbsp; :post-transform</h3></div><div><p>Like <code>:pre-transform</code> but later in the pipeline:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:student {:classes {:subject &quot;Math&quot;}}}
            {:pipeline {:fill-assoc {:student {:name &quot;BOB&quot;}}
                        :post-transform
                        {:student {:name capitalise}}}})
=&gt; #{{:student {:name &quot;Bob&quot;}}}</code></pre></div><div><p>Compared with a similar call to <code>:pre-transform</code>:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:student {:classes {:subject &quot;Math&quot;}}}
            {:pipeline {:fill-assoc {:student {:name &quot;BOB&quot;}}
                        :pre-transform
                        {:student {:name capitalise}}}})
=&gt; #{}</code></pre></div><div><span id="post-process"></span><h3>7.14 &nbsp;&nbsp; :post-process</h3></div><div><p>Final function that is called on the datastructure at the end of the pipeline:</p></div><div class="code"><pre><code class="clojure">(datomic/select school-ds
            {:student/name &quot;Charlie&quot;}
            {:pipeline
             {:post-process
              (fn [x _]
                (assoc-in x [:student :name] #{&quot;Bob&quot;}))}})
=&gt; #{{:student {:name &quot;Bob&quot;}}}</code></pre></div>
      </section>
    </div>
  </body>
  
  <script type="text/javascript">
    if (true) {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-31320512-2', 'caudate.me');
      ga('send', 'pageview');
    }
  </script>
  
  <script type="text/javascript">
    var metas = document.getElementsByTagName('meta');
    var i;
    if (navigator.userAgent.match(/iPhone/i)) {
      for (i=0; i<metas.length; i++) {
        if (metas[i].name == "viewport") {
          metas[i].content = "width=device-width, minimum-scale=1.0, maximum-scale=1.0";
        }
      }
      document.addEventListener("gesturestart", gestureStart, false);
    }
    function gestureStart() {
      for (i=0; i<metas.length; i++) {
        if (metas[i].name == "viewport") {
          metas[i].content = "width=device-width, minimum-scale=0.25, maximum-scale=1.6";
        }
      }
    }
  </script>
  
  <script type="text/javascript">
    
    //smoothScroll.init();
    //gumshoe.init();
    
    hljs.registerLanguage("clojure",function(e){var t={"builtin-name":"def defonce cond apply if-not if-let if not not= = < > <= >= == + / * - rem quot neg? pos? delay? symbol? keyword? true? false? integer? empty? coll? list? set? ifn? fn? associative? sequential? sorted? counted? reversible? number? decimal? class? distinct? isa? float? rational? reduced? ratio? odd? even? char? seq? vector? string? map? nil? contains? zero? instance? not-every? not-any? libspec? -> ->> .. . inc compare do dotimes mapcat take remove take-while drop letfn drop-last take-last drop-while while intern condp case reduced cycle split-at split-with repeat replicate iterate range merge zipmap declare line-seq sort comparator sort-by dorun doall nthnext nthrest partition eval doseq await await-for let agent atom send send-off release-pending-sends add-watch mapv filterv remove-watch agent-error restart-agent set-error-handler error-handler set-error-mode! error-mode shutdown-agents quote var fn loop recur throw try monitor-enter monitor-exit defmacro defn defn- macroexpand macroexpand-1 for dosync and or when when-not when-let comp juxt partial sequence memoize constantly complement identity assert peek pop doto proxy defstruct first rest cons defprotocol cast coll deftype defrecord last butlast sigs reify second ffirst fnext nfirst nnext defmulti defmethod meta with-meta ns in-ns create-ns import refer keys select-keys vals key val rseq name namespace promise into transient persistent! conj! assoc! dissoc! pop! disj! use class type num float double short byte boolean bigint biginteger bigdec print-method print-dup throw-if printf format load compile get-in update-in pr pr-on newline flush read slurp read-line subvec with-open memfn time re-find re-groups rand-int rand mod locking assert-valid-fdecl alias resolve ref deref refset swap! reset! set-validator! compare-and-set! alter-meta! reset-meta! commute get-validator alter ref-set ref-history-count ref-min-history ref-max-history ensure sync io! new next conj set! to-array future future-call into-array aset gen-class reduce map filter find empty hash-map hash-set sorted-map sorted-map-by sorted-set sorted-set-by vec vector seq flatten reverse assoc dissoc list disj get union difference intersection extend extend-type extend-protocol int nth delay count concat chunk chunk-buffer chunk-append chunk-first chunk-rest max min dec unchecked-inc-int unchecked-inc unchecked-dec-inc unchecked-dec unchecked-negate unchecked-add-int unchecked-add unchecked-subtract-int unchecked-subtract chunk-next chunk-cons chunked-seq? prn vary-meta lazy-seq spread list* str find-keyword keyword symbol gensym force rationalize"},r="a-zA-Z_\\-!.?+*=<>&#'",n="["+r+"]["+r+"0-9/;:]*",a="[-+]?\\d+(\\.\\d+)?",o={b:n,r:0},s={cN:"number",b:a,r:0},i=e.inherit(e.QSM,{i:null}),c=e.C(";","$",{r:0}),d={cN:"literal",b:/\b(true|false|nil)\b/},l={b:"[\\[\\{]",e:"[\\]\\}]"},m={cN:"comment",b:"\\^"+n},p=e.C("\\^\\{","\\}"),u={cN:"symbol",b:"[:]{1,2}"+n},f={b:"\\(",e:"\\)"},h={eW:!0,r:0},y={k:t,l:n,cN:"name",b:n,starts:h},b=[f,i,m,p,c,u,l,s,d,o];return f.c=[e.C("comment",""),y,h],h.c=b,l.c=b,{aliases:["clj"],i:/\S/,c:[f,i,m,p,c,u,l,s,d]}});
    hljs.initHighlightingOnLoad();
  </script>
  </html>